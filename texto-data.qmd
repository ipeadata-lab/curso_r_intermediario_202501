---
title: "Manipulação de datas e textos"
code-annotations: hover
# Manipulação de datas com lubridate - mostrar também no ggplot com scale_x_date()
# Expressões regulares: noções básicas (visão geral)
# Manipulação de strings com stringr
# Pareamento (probabilístico e fonético)  - pensar se vamos discutir
# left join window **/ intervalo**; fuzzy join**
---

No curso [Introdução à análise de dados com R](https://ipeadata-lab.github.io/curso_r_intro_202409/05_transformacao.html) exploramos algumas funções de transformação de dados. Nesta aula, vamos explorar funções específicas para manipulação de datas e textos.

Caso você tenha dúvidas sobre o tema, recomendamos revisar as seguintes aulas:

- [Como importar bases de dados](https://ipeadata-lab.github.io/curso_r_intro_202409/03_importacao.html)

-   [Função `dplyr::mutate()` para criar novas variáveis (colunas), ou alterar variáveis existentes](https://ipeadata-lab.github.io/curso_r_intro_202409/05_transformacao.html#criando-e-transformando-colunas-mutate)

## Dados

Antes de iniciar o conteúdo, vamos baixar a base de dados que utilizaremos nesta aula. A base de dados `voos_dez-2024-alterado.csv` apresenta informações sobre voos realizados em dezembro de 2024 realizados no Brasil. Esses dados foram obtidos com o pacote [`{flightsbr}`](https://ipeagit.github.io/flightsbr/), e foram alterados para fins didáticos.

```{r}
#| eval: false
download.file(
  url = "https://github.com/ipeadata-lab/curso_r_intermediario_202501/raw/refs/heads/main/dados/voos_dez-2024-alterado.csv", # <1>
  destfile = "dados/voos_dez-2024-alterado.csv", # <2>
  mode = "wb")
```
1. URL do arquivo a ser baixado.
2. Caminho onde o arquivo que será salvo.

Vamos carregar o pacote `{tidyverse}`:

```{r}
#| message: false
library(tidyverse)
```


Vamos importar a base de dados `voos_dez-2024-alterado.csv` e ver o resultado da função `glimpse()`:

```{r}
#| message: false
#| warning: false
voos <- read_csv2("dados/voos_dez-2024-alterado.csv") 
glimpse(voos)
```

## Manipulação de datas


### Tipo `Date`

Quando escrevemos datas em português, é comum utilizarmos o formato `dia/mês/ano` (por exemplo: 20/01/2025). Ao criar uma variável com esta no R, teremos um objeto do tipo `character` (texto):

```{r}
class("20/01/2025")
```

Porém no R existe um tipo específico para datas, o `Date`. O tipo `Date` é útil em vários contextos: permite realizar operações específicas para datas, como calcular a diferença entre duas datas, extrair o dia da semana, alterar a formatação de datas em gráficos, entre outros.

Para que o R reconheça um objeto com o tipo `Date`, precisamos salvar as datas no formato `ano-mês-dia` (por exemplo: 2025-01-20), e utilizar a função `as.Date()` para transformar a variável do tipo `character` em `Date`.

Exemplo:

```{r}
data_inicio_curso <- as.Date("2025-01-20")
data_inicio_curso
class(data_inicio_curso)
```

Porém, tome cuidado! Se você tentar transformar uma data no formato `dia/mês/ano` diretamente para `Date`, o R não irá reconhecer a data corretamente (e também não irá retornar um erro):

```{r}
as.Date("20/01/2025")
```

A função `Sys.Date()` retorna a data atual do sistema, com o tipo `Date`:

```{r}
Sys.Date()
class(Sys.Date())
```

::: {.callout-note collapse="true"}
## Curiosidade: o que é armazenado em uma variável do tipo `Date`?

O tipo `Date` armazena o **quantidade de dias** desde 1 de janeiro de 1970. Podemos verificar isso utilizando a função `as.numeric()` para obter o número armazenado em uma variável do tipo `Date`. Por exemplo, a data 1 de janeiro de 1970:

```{r}
data_1970 <- as.Date("1970-01-01")
data_1970
as.numeric(data_1970)
```

Um número negativo indica uma data anterior a 1 de janeiro de 1970, e um número positivo indica uma data posterior a essa data. Por exemplo, considerando a data de nascimento de [Julia Lopes de Almeida](https://jornal.usp.br/ciencias/ciencias-humanas/escritora-mais-publicada-da-primeira-republica-foi-vetada-na-abl/) (24 de setembro de 1862):

```{r}
nascimento_julia_lopes <- as.Date("1862-09-24")

as.numeric(nascimento_julia_lopes)
```

:::


#### Exercício

1.  Crie uma variável chamada `data_nascimento` com sua data de nascimento e transforme-a para o tipo `Date`.

2.  Crie uma variável chamada `data_atual` com a data atual do sistema.

3.  Calcule a diferença entre a data atual e a sua data de nascimento. O que é retornado?

```{r}
#| eval: false
#| echo: false
data_nascimento <- as.Date("1993-02-15")
data_atual <- Sys.Date()
diferenca <- data_atual - data_nascimento
diferenca / 365.25
```

4.  Utilize a função `Sys.time()` e guarde o resultado em uma variável.
    a.  O que essa função retorna?
    b.  Qual é o tipo da variável?

### Tipo `POSIXct` e `POSIXt`

O tipo `POSIXct` é uma extensão do tipo `Date`, que inclui informações de data, hora e fuso horário (em UTC: [Coordinated Universal Time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)). O formato padrão para datas e horas é `ano-mês-dia hora:minuto:segundo fuso_horario` (por exemplo: 2025-01-20 15:30:00 -03).

```{r}
Sys.time()
class(Sys.time())
```

Esse tipo armazena o número de segundos desde 1 de janeiro de 1970, no fuso horário UTC +0 (que é igual ao GMT).

**Nesta aula, vamos focar no tipo `Date`**, mas é importante saber que o R possui funções específicas para manipulação de datas e horas (caso você precise trabalhar com isso).

#### Exercício

1. Utilizando a base de dados `voos` (importada no início da aula), explore:
    a) Quais são as colunas que armazenam alguma data?
    b) Qual é o tipo de cada uma dessas colunas?
    c) Quais dessas precisariam ser transformadas para o tipo `Date`? Como você faria isso?
  

### Tipo `Date` e bases de dados

Até agora, exploramos como criar variáveis do tipo `Date` a partir de valores que digitamos diretamente no código. Porém, em muitos casos, as datas estão armazenadas em bases de dados.

A rotina mais comum é importar a base de dados, e caso a variável de data esteja no formato `character` (texto), utilizamos alguma função para transformá-la em `Date`.


Vamos explorar trabalhar com as datas da base de dados `voos`. As colunas que armazenam datas iniciam com o prefixo `dt_`. Vamos selecionar essas colunas e observar as primeiras linhas:

```{r}
voos_datas <- voos |> 
  select(starts_with("dt_")) # <1>

voos_datas |> 
  head() # <2>
```
1. Selecionamos apenas as colunas que iniciam com o prefixo `dt_`.
2. Exibimos as primeiras linhas da tabela.

- Exercício: identifique as colunas que armazenam datas na base de dados `voos`.

Com o resultado, vamos observar quais colunas são datas e quais não são:

- `dt_referencia`: O `readr` identificou que a coluna é uma data e já importou como `<date>`.

- `dt_partida_prevista`: está como tipo `<character>`. O formato é `dia/mês/ano`. Precisamos transformar para `<date>`.

- `dt_chegada_real`: está como `<double>`, em um formato numérico. Precisamos transformar para `<date>`.

- `dt_sistema`: está como `<dttm>`, ou seja, do tipo `POSIXct`. Vamos manter como está.

#### Transformando variáveis de texto em datas

Como vimos anteriormente, existem funções para transformar variáveis de texto em datas.
Vamos transformar a coluna `dt_partida_real` para o tipo `Date`.


Se a gente tentar transformar a coluna `dt_partida_real` diretamente para `Date`, o R não irá reconhecer a data corretamente (e também não irá retornar um erro):

```{r}
voos_datas |> 
  select(dt_partida_real) |> 
  mutate(
    dt_partida_real_date = as.Date(dt_partida_real) # <1>
  )
```

Então é importante lembrar que o R espera que a data esteja no formato `ano-mês-dia` para transformar em `Date`. Para isso, vamos utilizar a função `as.Date()` e especificar o formato da data, usando o argumento `format`: 

```{r}
voos_datas |> 
  select(dt_partida_real) |> 
  mutate(
    dt_partida_real_date = as.Date(dt_partida_real, format = "%d/%m/%Y")
  )
```

No argumento `format`, precisamos apresentar como a data está formatada. Ou seja: em `"%d/%m/%Y"`, `%d` representa o dia, `%m` representa o mês e `%Y` representa o ano.

Existe uma função do pacote `lubridate` que facilita a conversão de datas: a função `dmy()` (que significa "dia-mês-ano") e similares, mas vamos apresentá-las mais adiante.

::: {.callout-note collapse="true"}
## Extra: função `readr::parse_date()`

A função `readr::parse_date()` tem o mesmo propósito, porém ela apresenta alguns argumentos extras (como o `locale`). A [documentação dessa função é muito útil para entender como formatar datas](https://readr.tidyverse.org/reference/parse_datetime.html#format-specification).

```{r}
voos_datas |> 
  select(dt_partida_real) |> 
  mutate(
    dt_partida_real_date = parse_date(dt_partida_real, format = "%d/%m/%Y")
  )
```

Exemplo de um uso onde o `locale` é necessário: quando a data está escrita por extenso, em um idioma diferente do inglês:

```{r}
# Com as.Date(), fev não é reconhecido, pois em inglês é feb
as.Date("03/fev/2025", format = "%d/%b/%Y")

# Com o parse_date(), podemos informar o locale:
readr::parse_date("03/fev/2025",
                  format = "%d/%b/%Y",
                  locale = locale("pt"))
```

:::


#### Transformando datas do Excel para `Date`

A coluna `dt_chegada_real` foi importada como número (`Double`).

Será que conseguimos transformar essa coluna para `Date` apenas usando a função `as.Date()`?

```{r}
voos_datas |> 
  select(dt_chegada_real) |> 
  mutate(
    dt_chegada_real_date = as.Date(dt_chegada_real)
  )
```

As datas convertidas estão no futuro (o que não faz sentido, já que os voos ocorreram em dezembro de 2024). O que aconteceu?

Essa coluna está salva em um padrão comum de dados do Excel: o número de dias desde 01/01/1900. Para transformar essa coluna em `Date`, precisamos informar ao R que a data de referência é 30/12/1899 (um dia antes de 01/01/1900), utilizando o argumento `origin`:

```{r}
voos_datas |> 
  select(dt_chegada_real) |> 
  mutate(
    dt_chegada_real_date = as.Date(dt_chegada_real, origin = "1899-12-30")
  )
```

Não é muito prático ter que lembrar a data de referência para transformar datas do Excel em `Date`. Por isso, o `janitor` possui a função [`excel_numeric_to_date()`](https://sfirke.github.io/janitor/reference/excel_numeric_to_date.html) que faz essa conversão automaticamente:

```{r}
voos_datas |> 
  select(dt_chegada_real) |> 
  mutate(
    dt_chegada_real_date = janitor::excel_numeric_to_date(dt_chegada_real)
  )
```
#### Exercícios


1. Observe os valores abaixo, e identifique em qual formato de data estão. Como você transformaria esses valores para o tipo `Date`?
    a) `"2025-02-03"`
    b) `"03/02/2025"`
    c) `20122`
    d) `45691`

```{r}
#| eval: false
#| echo: false
# a)
as.Date("2025-02-03")
# b)
as.Date("03/02/2025", format = "%d/%m/%Y")
# c)
as.Date(20122)
# d) 
janitor::excel_numeric_to_date(45691)
# c)
readr::parse_date("03 de fevereiro de 2025", format = "%d de %B de %Y", locale = locale("pt"))
```



### Pacote `lubridate`


<img src="images/logo-lubridate.png" class="img-rstudio" align="right" width="120px"/>

O pacote `lubridate` faz parte do pacote `{tidyverse}` do R, e tem funções que facilitam a manipulação de datas. Ele possui funções específicas para extrair informações de datas, como dia, mês, ano, semana, entre outras.

```{r}
#| message: false
library(lubridate)
```

#### Funções de parse

Como citado anteriormente, quando queremos transformar uma data no formato `dia/mês/ano` para `Date`, podemos utilizar a função `dmy()` (que significa "dia-mês-ano"):

```{r}
voos_datas |> 
  select(dt_partida_real) |> 
  mutate(
    dt_partida_real_date = dmy(dt_partida_real)
  )
```

O `lubridate` também possui funções para transformar datas que estejam em outros formatos. O importante é lembrar que `y` representa o ano, `m` representa o mês e `d` representa o dia, e assim podemos combinar essas letras para formar o nome da função que precisamos usar para transformar a data. Se quiser saber mais sobre esse grupo de funções, acesse a [documentação oficial](https://lubridate.tidyverse.org/reference/ymd.html).

#### Extrair informações de datas

O `lubridate` possui funções para extrair informações de datas. No exemplo abaixo, vamos extrair o dia, mês e ano da coluna `dt_referencia`:

```{r}
voos_datas |> 
  select(dt_referencia) |> 
  mutate(
    dia = day(dt_referencia),
    mes = month(dt_referencia),
    ano = year(dt_referencia)
  )
```

Algumas funções tem argumentos que permitem personalizar a saída. Por exemplo, a função `month()` tem o argumento `label` que permite retornar o mês por extenso (em vez de numérico), o argumento `abbr` que permite retornar o mês abreviado, e o argumento `locale` que permite retornar o mês em outro idioma:

```{r}
voos_datas |>
  select(dt_referencia) |>
  mutate(
    mes_curto = month(dt_referencia, label = TRUE),
    
    mes = month(dt_referencia, label = TRUE, abbr = FALSE),
    
    mes_pt = month(
      dt_referencia,
      label = TRUE,
      abbr = FALSE,
      locale = "pt_BR"
    )
  )
```

::: {.callout-note collapse="true"}

## Extra: extrair o dia da semana de datas


A função `wday()` retorna o dia da semana, e também possui argumentos para personalizar a saída:

```{r}
voos_datas |>
  select(dt_referencia) |>
  mutate(
    dia_semana_numero = wday(dt_referencia),
    
    dia_semana = wday(dt_referencia, label = TRUE),
    
    dia_semana_abbr = wday(dt_referencia, label = TRUE, abbr = FALSE),
    
    dia_semana_pt = wday(
      dt_referencia,
      label = TRUE,
      abbr = FALSE,
      locale = "pt_BR"
    )
  )
```
:::

#### Arredondando datas

O lubridate também possui funções para arredondar datas. Por exemplo, a função `floor_date()` arredonda a data para o início de um intervalo de tempo (por exemplo, o início do mês):

```{r}
voos_datas |> 
  select(dt_referencia) |> 
  mutate(
    mes_arredondado = floor_date(dt_referencia, unit = "month"),
  )
```


#### Exercícios

1. Utilizando a base de dados `voos`, tente gerar a tabela abaixo utilizando a coluna `dt_partida_real`:

```{r}
#| echo: false

voos |> 
  select(dt_partida_real) |> 
  mutate(
    dt_partida_real = dmy(dt_partida_real),
    dia_partida = day(dt_partida_real),
    mes_partida = month(dt_partida_real, label = TRUE, locale = "pt_BR"),
    mes_partida_date = floor_date(dt_partida_real, unit = "month"),
    dia_semana_partida = wday(dt_partida_real, label = TRUE, locale = "pt_BR")
  )
```




### Datas em gráficos

Vamos criar um gráfico com o pacote `ggplot2` utilizando a base de dados `voos`. Vamos criar um gráfico de barras com a quantidade de voos por dia de partida, que partiram do aeroporto de Brasília - DF: PRESIDENTE JUSCELINO KUBITSCHEK.

```{r}
voos_brasilia <- voos |>
  filter(nm_aerodromo_origem == "PRESIDENTE JUSCELINO KUBITSCHEK")
```



Como essa coluna está originalmente salva como texto, o `ggplot2` entenderá que cada data é uma categoria (e não uma data), e o gráfico não será exibido corretamente:

```{r}
quantidade_voos_por_partida <- voos_brasilia |> 
  count(dt_partida_real) 

quantidade_voos_por_partida |> 
  ggplot(aes(x = dt_partida_real, y = n)) +
  geom_col() +
  labs(
    x = "Data",
    y = "Quantidade de voos",
    title = "Quantidade de voos por dia de partida"
  )
```
Para que o `ggplot2` entenda que a variável é uma data, precisamos transformá-la para o tipo `Date` (como visto anteriormente):

```{r}
quantidade_voos_partida_data <- voos_brasilia |>
  mutate(
    dt_partida_real_date = dmy(dt_partida_real)
  ) |>
  count(dt_partida_real_date)

quantidade_voos_partida_data
```

Agora vamos criar o gráfico com a data transformada. Observe que agora o `ggplot2` entende que a variável é uma data, e o gráfico é exibido corretamente:

```{r}
 grafico_voos <- quantidade_voos_partida_data |> 
  ggplot(aes(x = dt_partida_real_date, y = n)) +
  geom_col() +
  labs(
    x = "Data de partida",
    y = "Quantidade de voos",
    title = "Quantidade de voos por dia de partida",
    subtitle = "Voos que partiram do aeroporto de Brasília, em dezembro de 2024"
  ) +
  coord_trans(expand = FALSE) +
  theme_minimal()

grafico_voos
```

O pacote `ggplot2` possui funções específicas para trabalhar com datas em gráficos. Por exemplo, a função `scale_x_date()` permite personalizar o eixo x de um gráfico com datas. Essa função possui argumentos para personalizar o formato das datas (`date_labels`), e o intervalo entre as datas (`date_breaks`).

```{r}
grafico_voos +
  scale_x_date(date_labels = "%d", date_breaks = "1 day") 
```
#### Exercícios

1. Utilizando o gráfico criado anteriormente, personalize o eixo x para exibir o `dia/mês` de cada data (como `12/dez`), e o intervalo entre as datas seja de 7 dias.

```{r}
#| eval: false
#| echo: false
grafico_voos +
  scale_x_date(date_labels = "%d/%b", date_breaks = "7 day") 
```

2. Os nomes dos meses estão em inglês ou em português? Caso esteja em inglês, como você faria para exibir os nomes dos meses em português?

```{r}
#| eval: false
#| echo: false
Sys.setlocale("LC_ALL", "pt_br.utf-8") 
grafico_voos +
  scale_x_date(date_labels = "%d/%b", date_breaks = "7 day") 
```
::: callout-tip
Dica: a função `Sys.setlocale()` permite alterar o locale utilizado pelo R.

```{r}
#| eval: false
Sys.setlocale("LC_ALL", "pt_br.utf-8") 
```
:::


## Manipulação de textos (*strings*)

Nesta seção, vamos explorar funções para manipulação de textos (*strings*). Isso é útil para extrair informações de textos, fazer limpeza de dados, realizar filtros, entre outros.


### O pacote `stringr`


<img src="images/logo-stringr.png" class="img-rstudio" align="right" width="120px"/>

O pacote `stringr` é um pacote do `tidyverse` que facilita a manipulação de strings. Ele possui funções para detectar padrões em strings, extrair informações, substituir textos, tratar textos, entre outros.

A maioria das funções do pacote tem o prefixo `str_`, o que facilita a identificação das funções que trabalham com strings.  De início, vamos explorar algumas funções básicas para detectar e extrair padrões em strings:

- [`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.html): verifica se um padrão está presente em uma string. O resultado é um vetor lógico (`TRUE` ou `FALSE`).

- [`str_extract()` e `str_extract_all()`](https://stringr.tidyverse.org/reference/str_extract.html): extrai o primeiro ou todos os padrões encontrados em uma string.

- [`str_subset()`](https://stringr.tidyverse.org/reference/str_subset.html) - extrai as strings que contêm o padrão.

Essas funções seguem a mesma sintaxe: o primeiro argumento é a string, e o segundo argumento é o padrão que queremos buscar. 

Para entender como trabalhar com esses padrões, precisamos conhecer o conceito de expressões regulares (`regex`). Vamos explorar isso a seguir, e depois voltamos para o `stringr`!


### Introdução à Expressões regulares (`regex`)

As expressões regulares (ou `regex`) são padrões utilizados para encontrar e substituir textos em strings. Elas são muito úteis para realizar buscas complexas em textos, e são utilizadas em várias linguagens de programação (ou seja, não são exclusivas do R).

Existem alguns caracteres especiais que são utilizados nas expressões regulares. Alguns exemplos:

- `.` (qualquer caractere)
- `^` (início da string)
- `$` (fim da string)
- `*`, `+`, `?` (quantificadores)
- `[]` (conjunto de caracteres)
- `{}` (quantificadores numéricos)
- `\d` (dígitos: 0-9)
- `\w` (letras e dígitos)

O site [regexer](https://regexr.com/) é uma ferramenta muito útil para testar expressões regulares. Você pode inserir um texto, e testar diferentes expressões regulares para encontrar padrões no texto. O ChatGPT (e outras ferramentas similares) também podem ser usados para interpretar expressões regulares.

::: {.callout-caution}
Existem alguns caracteres que precisamos "escapar" com `\` para que sejam interpretados como caracteres literais. 

- No R, a barra invertida (`\`) é um caractere de escape. Quando queremos utilizar uma barra invertida em uma expressão regular, precisamos "escapar" a barra invertida com outra barra invertida.


Por exemplo, se quisermos encontrar um dígito (`\d`), precisamos escrever `\\d`. Caso você encontre um erro como o abaixo, provavelmente é porque você esqueceu de escapar um caractere especial:

```{r}
#| error: true
str_extract("123", "\d")
```

```{r}
str_extract("123", "\\d")
```


:::

Vamos tentar interpretar o que cada um dos padrões a seguir faz (tente responder antes de abrir a resposta):

::: {.callout-note collapse="true"}
## Exemplo 1: `"*.csv$"`

Esse padrão é utilizado para encontrar arquivos que terminam com a extensão `.csv`. O `*` significa que pode ter qualquer caractere antes de `.csv`, e o `$` indica que `.csv` deve ser o final da string.

Isso é útil para encontrar arquivos em um diretório, por exemplo:
```{r}
fs::dir_ls("dados", glob = "*.csv$")
```
:::



::: {.callout-note collapse="true"}
## Exemplo 2: `"\\d{2}"`

Esse padrão é utilizado para encontrar dois dígitos em uma string. O `\\d` representa um dígito, e `{2}` indica que devem ser dois dígitos.

Este exemplo é útil para compreender o exemplo a seguir!
:::


::: {.callout-note collapse="true"}
## Exemplo 3: `"\\d{2}/\\d{2}/\\d{4}"`

Esse padrão busca por datas no formato `dia/mês/ano`. O `\\d` representa um dígito, e `{2}` indica que devem ser dois dígitos. As barras (`/`) são caracteres literais, e o `{4}` indica que o ano deve ter quatro dígitos.

Isso é útil para extrair datas de um texto, por exemplo:
```{r}
texto <- "Neste ano, o carnaval será entre os dias 03/03/2025 e 05/03/2025 (quarta-feira de cinzas)."

str_extract_all(texto, "\\d{2}/\\d{2}/\\d{4}")
```
:::


#### Exercícios

1.  O código abaixo deveria retornar todos os elementos do vetor que estão com a palavra "R$". Porém, ele retorna um caractere vazio. Por que isso acontece? Como você faria para corrigir?

```{r}
valores <- c("R$ 100", "USD 200", "300€", "R$ 200")
str_subset(valores, "R$") 
```
2. Considerando o vetor `palavras_pro`:

```{r}
palavras_pro <- c("processo", "projeto", "produto",
                  "improviso", "aprovar", "professora",
                  "floresta", "prédio", "prova", "problema")
```

a) Qual é a diferença entre os padrões a seguir? O que você acha que cada um deles faz? Quais palavras você acha que serão retornadas em cada caso?

```{r}
#| eval: false
str_subset(palavras_pro, "^pro")

str_subset(palavras_pro, "pro")
```

3. Utilizando o vetor `emails` abaixo, crie um código que retorne apenas os emails válidos (ou seja, que possuem o formato `nome@provedor.etc`). Não precisa ser a solução perfeita, mas tente pensar em como você faria isso.

```{r}
emails <- c("joao@gmail.com",
            "maria@outlook",
            "contato@empresa.org",
            "isso_nao_eh_email")
```

### Manipulação de strings com `stringr`


Nos exemplos anteriores, utilizamos funções básicas do `stringr` para detectar e extrair padrões em strings. 

Podemos também utilizar essas funções juntamente com o `dplyr` para realizar transformações em bases de dados.

#### Filtros com `str_detect()`

No curso introdutório, aprendemos a utilizar a função `filter()` do `dplyr` para filtrar linhas de uma base de dados. Porém o `filter()` busca por valores exatos, e não por padrões em strings.


Se pesquisarmos por voos que saíram de Congonhas, podemos usar o `filter()` para encontrar exatamente "CONGONHAS":
```{r}
voos |> 
  filter(nm_aerodromo_origem == "CONGONHAS")
```

Porém caso queiramos encontrar voos que saíram de Guarulhos, não basta usar o `filter()` com `==`, pois o nome do aeroporto está escrito de forma diferente ("GUARULHOS - GOVERNADOR ANDRÉ FRANCO MONTORO"):

```{r}
voos |> 
  filter(nm_aerodromo_origem == "GUARULHOS")
```


A função `str_detect()` retorna um vetor lógico (`TRUE` ou `FALSE`) indicando se um padrão está presente em uma string. Isso é muito útil para usar com a função `filter()` (do `dplyr`), para filtrar strings que contêm um padrão específico. Neste caso, podemos usar a função `str_detect()` para filtrar strings que contêm um padrão específico:

```{r}
voos |> 
  filter(str_detect(nm_aerodromo_origem, "GUARULHOS"))
```

Imagine que queremos descobrir quais são os destinos possíveis a partir dos aeroportos de Guarulhos e Congonhas (localizados na Região Metropolitana de São Paulo). Podemos utilizar a função `str_detect()` + `filter()` para filtrar estas origens. Observe que utilizamos o operador `|` para indicar que queremos encontrar voos que saíram de Guarulhos **ou** Congonhas:

```{r}
voos |> 
  filter(str_detect(nm_aerodromo_origem, "GUARULHOS|CONGONHAS")) |> 
  count(nm_aerodromo_origem, nm_municipio_destino, nm_pais_destino, sort = TRUE)
```

#### `mutate()` e stringr

A função `mutate()` do `dplyr` é muito útil para criar novas variáveis em uma base de dados. Podemos utilizar o `mutate()` juntamente com o `stringr` para realizar vários tipos de  transformações em strings. Existem muitas funções do `stringr` que podem ser utilizadas com o `mutate()`, como:

- [`str_extract()` e `str_extract_all()`](https://stringr.tidyverse.org/reference/str_extract.html): extrai o padrão encontrado em uma string.

- [`str_replace()` e `str_replace_all()`](https://stringr.tidyverse.org/reference/str_replace.html): substitui um padrão por outro.

- [`str_remove()` e `str_remove_all()`](https://stringr.tidyverse.org/reference/str_remove.html): remove um padrão de uma string.

- [`str_squish()`](https://stringr.tidyverse.org/reference/str_trim.html): remove espaços em branco extras de uma string.

- [`str_to_lower()`, `str_to_upper()`, `str_to_sentence()`, `str_to_title()`](https://stringr.tidyverse.org/reference/case.html): converte uma string para minúsculas ou maiúsculas.

```{r}
voos |> 
  mutate(
    nm_aerodromo_origem = str_squish(nm_aerodromo_origem),
    nm_aerodromo_origem = str_to_title(nm_aerodromo_origem),
    nm_aerodromo_origem = str_replace_all(nm_aerodromo_origem, " Do ", " do "),
    nm_aerodromo_origem = str_replace_all(nm_aerodromo_origem, " De ", " de "),
    nm_aerodromo_origem = str_replace_all(nm_aerodromo_origem, " Da ", " da "),
  ) |> 
  count(nm_aerodromo_origem, sort = TRUE)
```





#### Exercícios

1. Imagine que queremos criar uma tabela com as principais empresas aéreas que realizaram voos em dezembro de 2024, saindo do aeroporto de Brasília. Para isso, precisamos filtrar os vôos que partiram de Brasília, e contar quantos voos cada empresa realizou! 

a) Filtre os voos que partiram de Brasília, e conte quantos voos cada empresa realizou.

```{r}
#| eval: false
#| echo: false
voos_brasilia <- voos |> 
  filter(nm_municipio_origem == "BRASÍLIA") 

voos_brasilia |> 
  count(nm_empresa, sort = TRUE)
```

b) O que você achou do resultado? Você acha que ele está correto? Por que?

c) Como você faria para apresentar uma tabela com as três principais empresas aéreas que realizaram voos em Brasília?


```{r}
#| eval: false
#| echo: false
principais_empresas_brasilia <- voos |>
  filter(nm_municipio_origem == "BRASÍLIA") |> 
  filter(str_detect(nm_empresa, "^GOL |^AZUL |^TAM |^LATAM ")) |>
  mutate(nm_empresa_reclassificado = case_when(
    str_detect(nm_empresa, "^GOL") ~ "GOL",
    str_detect(nm_empresa, "^AZUL") ~ "AZUL",
    str_detect(nm_empresa, "^TAM|^LATAM") ~ "LATAM",
  )) |>
  count(nm_empresa_reclassificado, sort = TRUE)
```


### Extra 

#### Joins

Os joins são operações que combinam duas ou mais tabelas em uma única tabela. No [curso Introdução à análise de dados no R](https://ipeadata-lab.github.io/curso_r_intro_202409/05_transformacao.html#unindo-duas-bases-de-dados-left_join), conhecemos algumas funções de join do pacote `dplyr`.

Para fazer joins, precisamos ter uma variável em comum entre as tabelas (chamada de chave). Porém, em alguns casos as chaves não são exatamente iguais, e precisamos utilizar funções do pacote `{stringr}` para transformar as colunas, de forma que os valores fiquem correspondentes; ou comparar strings de forma mais flexível.


O pacote [`{fuzzyjoin}`](https://github.com/dgrtwo/fuzzyjoin) permite fazer joins entre tabelas considerando similaridade entre textos, utilizando técnicas de *fuzzy join*, que permite unir tabelas com base em similaridade parcial entre as chaves, em vez de exigir correspondência exata. Isso é útil quando trabalhamos com bases de dados que podem ter inconsistências, como erros de digitação em nomes de pessoas ou pequenas variações em endereços.

<!-- Pareamento (probabilístico e fonético)  - pensar se vamos discutir -->
<!-- left join window **/ intervalo**; fuzzy join** -->

## Material complementar

-   Capítulos do livro ["R para Ciência de Dados" (2 ed)](https://pt.r4ds.hadley.nz/) por Hadley Wickham, Mine Çetinkaya-Rundel, e Garrett Grolemund:
    -   [Datas e horários](https://pt.r4ds.hadley.nz/datetimes.html)
    -   [Strings](https://pt.r4ds.hadley.nz/strings.html)
    -   [Expressões regulares](https://pt.r4ds.hadley.nz/regexps.html)
    
- Slides da Curso-R:
  - [Trabalhando com strings (textos)](https://curso-r.github.io/202409-r4ds-2/slides/02_strings.html#1)
  - [Trabalhando com datas e fatores](https://curso-r.github.io/202409-r4ds-2/slides/03_datas_fatores.html#1)
