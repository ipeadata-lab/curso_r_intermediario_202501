---
title: "Introdução à *Big Data*"
code-annotations: hover
---

## Introdução

Neste curso (e na maior parte do [curso introdutório](https://ipeadata-lab.github.io/curso_r_intro_202409/)), focamos em trabalhar com conjuntos de dados pequenos e que cabem na memória RAM do computador.  Isso permite que possamos carregar, manipular e analisar os dados diretamente no R sem grandes preocupações com limitações de hardware.

No entanto, muitas vezes, os dados são grandes demais para caber na memória do computador. Neste caso, é necessário usar técnicas diferentes para trabalhar com esses dados.

::: {.callout-note}

## Big Data

O termo *Big Data* é usado para descrever conjuntos de dados que são tão grandes ou complexos que se tornam difíceis de processar com ferramentas tradicionais. 

*Big Data* é geralmente definido em termos de ["3 Vs": volume, variedade, velocidade](https://cloud.google.com/learn/what-is-big-data).

Nesta aula, vamos utilizar este termo para descrever **conjuntos de dados que são grandes demais para caber na memória do computador**.

> *"“Big Data” is a relative term depending on who is discussing it. Big Data to Amazon or Google is very different than Big Data to a medium-sized insurance organization, but no less “Big” in the minds of those contending with it."* ([A Brief History of Big Data, Keith D, 2017](https://www.dataversity.net/brief-history-big-data/))
:::

Caso não tenha os pacotes necessários instalados, você pode instalar executando o código abaixo:

```{r}
#| eval: false
pacotes <- c("DBI", "RSQLite", "dbplyr", "arrow")
install.packages(pacotes)
```




## Banco de dados SQL

Grande parte dos dados utilizados em pesquisas e análises estão armazenados em bancos de dados relacionais, que utilizam a linguagem SQL (*Structured Query Language*) para consulta e manipulação de dados. 

O objetivo desta aula **não** é ensinar SQL, mas sim mostrar como podemos usar o R para se conectar a um banco de dados SQL e realizar consultas e manipulações de dados.

O fluxo de trabalho para trabalhar com dados armazenados em bancos de dados SQL no R é semelhante ao que já aprendemos com o uso de `data.frames` e `tibbles`, mas possui algumas diferenças, como:

- **Conectar com o banco de dados:** em vez de carregar a base completa no R (como fazemos com arquivos `.csv`), precisamos fazer uma conexão com o banco de dados.

- **Pensar no problema que queremos resolver:** antes de realizar qualquer consulta, é importante ter em mente o que queremos analisar e quais dados são necessários.  Por exemplo: se queremos fazer uma análise dos dados da RAIS em um ano específico, e para um estado específico, não faz sentido carregar todos os dados da RAIS no R. Precisamos pensar em quais operações são necessárias.


- **Consulta:** Fazer as operações necessárias no banco de dados para obter os dados desejados. 


- **Coletar os dados:** após realizar a consulta, precisamos "coletar" os dados no R para realizar análises. 

- **Desconectar do banco de dados:** após finalizar as análises, é importante desconectar do banco de dados.

- **Continuar a análise:** após coletar os dados, podemos continuar a análise como fizemos anteriormente.

### Conexão com bancos de dados SQL

O pacote [`{DBI}`](https://dbi.r-dbi.org/) (*R Database Interface*) é uma interface para se conectar a bancos de dados SQL. Ele fornece funções que permitem se conectar a diferentes bancos de dados SQL, permitindo que você use a mesma sintaxe.

Para se conectar a um banco de dados específico, você precisa instalar o pacote que fornece a conexão com o banco de dados, como:

  - PostgreSQL (com o pacote [`{RPostgres}`](https://rpostgres.r-dbi.org/))

  - MySQL ou MariaDB (com o pacote [`{RMariaDB}`](https://rmariadb.r-dbi.org/))

  - SQLite (com o pacote [`{RSQLite}`](https://rsqlite.r-dbi.org/))

  - Google Big Query (com o pacote [`{bigrquery}`](https://bigrquery.r-dbi.org/))

  - odbc (com o pacote [`{odbc}`](https://odbc.r-dbi.org/))


```{r}
# install.packages("DBI")
library(DBI)
```

O pacote DBI apresenta funções para se conectar a um banco de dados, como `dbConnect()` e `dbDisconnect()`.

Vamos explorar a função `dbConnect()` para conectar a um banco de dados. Essa função recebe como argumento `drv`  (o driver do banco de dados) e as informações necessárias para a conexão, como: o nome do banco de dados, o usuário, senha, entre outros.


Geralmente, acessamos bancos de dados SQL em um servidor, que requer credenciais de acesso, como usuário e senha.

O código abaixo mostra um exemplo de conexão com um banco de dados PostgreSQL:

```{r}
#| eval: false
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = "...",
    user = "...",
    port = 5432,
    password = "..."
  )
```

No exemplo acima, estamos nos conectando a um banco de dados PostgreSQL, informando o host, usuário, porta e senha. As informações de conexão dependem do banco de dados que você está utilizando, e você deve consultá-las com o administrador do banco de dados.

Perceba que o código acima salva o resultado da conexão no objeto `con`. Utilizaremos esse objeto para realizar o acesso ao banco de dados.

Também é possível se conectar a um banco de dados SQLite, que é um banco de dados disponibilizado em um arquivo, e que não requer um servidor:

```{r}
#| eval: false
con <- dbConnect(drv = RSQLite::SQLite(),
                 # caminho para um arquivo SQLite
                 dbname = "dados/flights_br.sqlite")
```


Conseguimos listar as tabelas disponíveis no banco de dados com a função `dbListTables()`:

```{r}
#| eval: false
dbListTables(con)
# [1] "voos"
```

Algo importante a se destacar é que, ao finalizar a análise, é importante desconectar do banco de dados com a função `dbDisconnect()`:

```{r}
#| eval: false
dbDisconnect(con)
```



## Utilizando a sintaxe do dplyr 

<img src="images/logo-dplyr.png" class="img-rstudio" align="right" width="120px"/>

No curso anterior, aprendemos a usar o pacote `{dplyr}` para manipulação de dados. No entanto, exploramos apenas a utilização com o uso de `data.frames` e `tibbles`.

No entanto, o `{dplyr}` possui suporte para diferentes *backends* que permitem trabalhar com conjuntos de dados que não cabem na memória do computador. Isso significa que podemos usar a mesma sintaxe do `{dplyr}` para manipular dados armazenados em bancos de dados SQL, em arquivos Apache Arrow, entre outros. Na documentação, podemos encontrar uma lista de *backends* disponíveis: [dplyr backends](https://dplyr.tidyverse.org/#backends).

Vamos explorar dois pacotes que apresentam backends do dplyr: [`{dbplyr}`](https://dbplyr.tidyverse.org/articles/dbplyr.html) (para trabalhar com dados armazenados em bancos de dados sql) e [`{Arrow}`](https://arrow.apache.org/docs/r/articles/arrow.html).

## dbplyr

<img src="images/logo-dbplyr.png" class="img-rstudio" align="right" width="120px"/>


Em breve!

<!-- dbplyr: Uma interface que permite usar a sintaxe do dplyr para manipular dados armazenados em bancos de dados SQL, sem precisar carregar os dados inteiramente na memória. -->


<!-- # DuckDB e SQL -->

<!-- DuckDB e SQL: DuckDB é um banco de dados embutido altamente otimizado para consultas analíticas, permitindo trabalhar com grandes conjuntos de dados de forma eficiente sem necessidade de um servidor externo. -->

## Arrow

<img src="images/logo-arrow.png" class="img-rstudio" align="right" width="120px"/>

Em breve!

<!-- Arrow: Permite o uso do formato Apache Arrow para leitura e escrita de dados de forma otimizada, reduzindo o tempo de processamento e permitindo o uso de dados maiores que a memória RAM. -->


## Material complementar

- Capítulos do livro ["R para Ciência de Dados" (2 ed)](https://pt.r4ds.hadley.nz/) por  Hadley Wickham, Mine Çetinkaya-Rundel, e Garrett Grolemund:
  - [Bancos de dados](https://pt.r4ds.hadley.nz/databases.html)
  - [Arrow](https://pt.r4ds.hadley.nz/arrow.html)

